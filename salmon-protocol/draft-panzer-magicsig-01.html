<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Draft: Magic Signatures</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Magic Signatures">
<meta name="keywords" content="signatures, PKI">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: small; color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: small; font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: small; font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: small; text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Draft</td><td class="header">J. Panzer, Ed.</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">B. Laurie</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">D. Balfanz</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Google Inc.</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">January 7, 2011</td></tr>
</table></td></tr></table>
<h1><br />Magic Signatures</h1>

<h3>Abstract</h3>

<p>This document defines a lightweight, robust mechanism for digitally signing nearly 
         arbitrary messages,
         along with a simple public key infrastructure.
</p>
<p>It is intended to be a building block in the construction of protocols, providing
         a commonly agreed upon abstraction layer on top of lower level specifications such as 
         <a class='info' href='#LRDD'>Webfinger/LRDD<span> (</span><span class='info'>Eran, E., &ldquo;LRDD: Link-based Resource Descriptor Discovery,&rdquo; .</span><span>)</span></a> [LRDD], <a class='info' href='#XRD'>XRD<span> (</span><span class='info'>Eran, EHL. and WN. Will, &ldquo;Extensible Resource Descriptor (XRD) Version 1.0, Working Draft 13,&rdquo; .</span><span>)</span></a> [XRD], 
         and <a class='info' href='#RFC3447'>PKCS<span> (</span><span class='info'>Jonsson, J. and B. Kaliski, &ldquo;Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1,&rdquo; February&nbsp;2003.</span><span>)</span></a> [RFC3447].  It is not a complete protocol in 
         itself, and requires that dependent protocols document the specific profile(s) used.
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.1.</a>&nbsp;
Requirements Language<br />
<a href="#definitions">2.</a>&nbsp;
Definitions<br />
<a href="#anchor3">3.</a>&nbsp;
Magic Envelope Definition<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#params">3.1.</a>&nbsp;
Magic Envelope Parameters<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sbs">3.2.</a>&nbsp;
The Signature Base String<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#compact">3.3.</a>&nbsp;
The Magic Envelope Compact Serialization<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">3.4.</a>&nbsp;
The Magic Envelope XML Serialization<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">3.5.</a>&nbsp;
The Magic Envelope JSON Serialization<br />
<a href="#anchor6">4.</a>&nbsp;
Standalone Magic Envelope Messages<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">4.1.</a>&nbsp;
Syndicating Magic Envelope Messages<br />
<a href="#encoding">5.</a>&nbsp;
Encoding of data and sig using base64url<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#encoding_details">5.1.</a>&nbsp;
Encoding<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">5.2.</a>&nbsp;
Decoding<br />
<a href="#anchor9">6.</a>&nbsp;
The HMAC-SHA256 Private Key Signature Algorithm<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">6.1.</a>&nbsp;
Calculating the HMAC-SHA256 signature string<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">6.2.</a>&nbsp;
Signing and Verifying Messages with HMAC-SHA256<br />
<a href="#anchor12">7.</a>&nbsp;
The RSA-SHA256 Public Key Signature Algorithm<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#signing">7.1.</a>&nbsp;
Signing Messages with RSA-SHA256<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#verifying">7.2.</a>&nbsp;
Verifying Messages with RSA-SHA256<br />
<a href="#mpki">8.</a>&nbsp;
Magic Public Key Infrastructure<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">8.1.</a>&nbsp;
The application/magic-key MIME type<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">8.2.</a>&nbsp;
Discovery<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">8.2.1.</a>&nbsp;
The JSON Serialization of Magic Keys<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">8.2.2.</a>&nbsp;
The XRD XML Serialialization of Magic Keys<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">8.2.3.</a>&nbsp;
Discovery Flow<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">8.2.4.</a>&nbsp;
Key Selection<br />
<a href="#Acknowledgements">9.</a>&nbsp;
Acknowledgements<br />
<a href="#IANA">10.</a>&nbsp;
IANA Considerations<br />
<a href="#Security">11.</a>&nbsp;
Security Considerations<br />
<a href="#rfc.references1">12.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">12.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">12.2.</a>&nbsp;
Informative References<br />
<a href="#anchor21">Appendix&nbsp;A.</a>&nbsp;
Specification Feedback<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>The primary goal of Magic Signatures is to enable lightweight and robust public key signing 
         for messages that may be transformed, converted, stored, and reconstituted in arbitrary ways.  
         In order to make this mechanism useful, it also defines a public key discovery protocol that enables 
         recipients to reliably map from URIs for signers to their public keys.  It also allows for
         private key signatures, but leaves private key exchange mechanisms unspecified.
</p>
<p>This mechanism is an alternative to XML Signature <a class='info' href='#XMLDSIG'>[XMLDSIG]<span> (</span><span class='info'>, &ldquo;XML Signature Syntax and Processing (Second Edition),&rdquo; .</span><span>)</span></a>.
         Compared to XML Signature, Magic Signatures offers 
         the following trade-offs:
         </p>
<ol class="text">
<li>Handles all payload data formats uniformly.
</li>
<li>Does not require use of an XML processor for non-XML payloads.
</li>
<li>Does not require any canonicalization beyond removal of whitespace, so it is much easier
              to verify messages correctly.
</li>
<li>Can survive message disassembly, storage into arbitrary systems, and 
              re-constitution without invalidating the signature (but it is not possible to sign
              only part of a message).
</li>
<li>Significantly smaller and simpler specification.
</li>
</ol><p>
         Magic Signatures does not attempt to address every XML Signature use case, so it is best
         described as a lightweight, robust, and minimal form of digital signatures that can be used
         and deployed where XML Signatures has proven problematic in the field, for example
         feed syndication (see <a class='info' href='#RFC4287'>[RFC4287]<span> (</span><span class='info'>Nottingham, M., Ed. and R. Sayre, Ed., &ldquo;The Atom Syndication Format,&rdquo; December&nbsp;2005.</span><span>)</span></a> section 5.1).  Note that it is possible to combine both 
         signature mechanisms if desired.
      
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Requirements Language</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <a class='info' href='#RFC2119'>RFC 2119<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> [RFC2119].
</p>
<a name="definitions"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Definitions</h3>

<p>
        </p>
<blockquote class="text"><dl>
<dt>Signature:</dt>
<dd>A digital signature that provably binds a message to a signer's secret key.
</dd>
<dt>Signer:</dt>
<dd>In this specification, an arbitrary URI used to determine a key
              used to sign an envelope.  This specification does not dictate how signer URIs are to
              be determined, but in the usual case they are embedded within the signed data and
              extracted via a data format specific algorithm.
</dd>
<dt>Public Key Infrastructure (PKI)</dt>
<dd>A set of hardware, software, people, policies, and 
              procedures needed to create, manage, distribute, use, store, and revoke digital certificates.
              This specification uses a very simple, limited PKI.
</dd>
</dl></blockquote><p>
      
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Magic Envelope Definition</h3>

<p>A "Magic Envelope" comprises a message bundled along with signature(s) for that message, expressed
      as a series of parameters, and serialized as a compact string, JSON, or XML.  The envelope specifies the data
      to be signed, the MIME type of the data, the transfer encoding, and the signature.
</p>
<a name="params"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Magic Envelope Parameters</h3>

<p>
        This section describes the semantics of the parameters independent of the serialization used.
        </p>
<blockquote class="text"><dl>
<dt>data:</dt>
<dd>The payload covered by the signature, encoded into an ASCII string.  
          This string is guaranteed to be safe to include without escaping as XML text
          and in JSON strings.  Appears exactly once.
</dd>
<dt>data_type:</dt>
<dd>The <a class='info' href='#RFC2045'>MIME<span> (</span><span class='info'>Freed, N. and N. Borenstein, &ldquo;Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies,&rdquo; November&nbsp;1996.</span><span>)</span></a> [RFC2045] type of the payload prior to encoding.  Appears exactly once.
</dd>
<dt>encoding:</dt>
<dd>The encoding used to convert between the MIME type and the "data" string.
          In this specification, encoding MUST be the string "base64url", indicating the url safe base64
          encoding as described in <a class='info' href='#RFC4648'>RFC 4648<span> (</span><span class='info'>Josefsson, S., &ldquo;The Base16, Base32, and Base64 Data Encodings,&rdquo; October&nbsp;2006.</span><span>)</span></a> [RFC4648], sans any trailing padding
          with equals (=) characters, and with the additional whitespace
          normalization rules specified in <a class='info' href='#encoding_details'>Section&nbsp;5.1<span> (</span><span class='info'>Encoding</span><span>)</span></a>.  All
          implementations MUST support this encoding.  Appears exactly once.
</dd>
<dt>alg:</dt>
<dd>The algorithm used for the signature.
          This specification describes only one 
          public key signature algorithm, "RSA-SHA256", and one private key signature algorithm,
          "HMAC-SHA256".  Specifications relying on Magic Signatures MUST specify which of these MUST
          be supported for a particular protocol.  Implementations of general Magic Signatures
          SHOULD support both for maximum interoperability.  Appears exactly once.
</dd>
<dt>sig:</dt>
<dd>A generated signature.  This is a string in the base64url encoded format as described
          above.  It is generated according to the rules for the "alg" in use.  A Magic Envelope has one or more
          signatures.  Each signature has at most one associated "key_id"
          parameter.
</dd>
<dt>key_id:</dt>
<dd>Optional hint indicating which specific key owned by the signer
        should be used to verify the signature.  This allows signers to explicitly signal
        a change of key to recipients.  Omitting this parameter is equivalent to setting it
        to an empty string.  The format of this parameter is
        unspecified except that all characters must be from the
        base64url allowed character set.  Thus, "", "1", "AH478=",
        "0x6EF37D", and "fred" are all legal key_ids.  The exact format
        is up to the key issuer.  Note that any binary data can be converted
        into an acceptable key_id by base64url encoding it.  One way to generate
        a usable key_id is to base64url-encode the SHA256 hash of the public signing key's
        magicsig representation; this allows a signer to provide usable ids without maintaining
        a mapping table.
</dd>
</dl></blockquote><p>
        
</p>
<a name="sbs"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
The Signature Base String</h3>

<p>The Signature Base String used for both RSA-SHA256 and HMAC-SHA256 is described here.
        It is used as input to the signature algorithms, as well as to create the <a class='info' href='#compact'>Compact Serialization<span> (</span><span class='info'>The Magic Envelope Compact Serialization</span><span>)</span></a>, below.
</p>
<p>Given a Magic Envelope with "data", "data_type", "encoding", and "alg" parameters, the
        corresponding Signature Base String is produced by concatenating the following substrings
        together, separated by periods (ASCII 0x2E):
</p>
<p>
        </p>
<ol class="text">
<li>The armored string for "data" produced by <a class='info' href='#encoding_details'>Section&nbsp;5.1<span> (</span><span class='info'>Encoding</span><span>)</span></a>
</li>
<li>The Base64url encoding of the "data_type" parameter
</li>
<li>The Base64url encoding of the "encoding" parameter
</li>
<li>The Base64url encoding of the "alg" parameter
</li>
</ol><p>
        An omitted parameter is represented by a zero length placeholder string.
        
</p>
<a name="compact"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
The Magic Envelope Compact Serialization</h3>

<p>The Magic Envelope Compact Serialization stores the envelope itself in a compact,
        armored form suitable for storage as a simple string.  It is guaranteed to contain no
        spaces and no URL unsafe characters, and allows for only a single signature.
</p>
<p>Given a singly signed envelope with one "sig" and one "key_id", the Compact
        Serialization is produced by concatenating the
        following substrings together, separated by periods (ASCII 0x2E):
</p>
<p>
        </p>
<ol class="text">
<li>The value of the "key_id" parameter
</li>
<li>The value of the "sig" parameter
</li>
<li>The Signature Base String as described in <a class='info' href='#sbs'>The Signature Base
          String<span> (</span><span class='info'>The Signature Base String</span><span>)</span></a>, above.
</li>
</ol><p>
        
</p>
<p>
        For example, if the key_id is "4k8ikoyC2Xh+8BiIeQ+ob7Hcd2J7/Vj3uM61dy9iRMI=",
        the "sig" is "EvGSD2vi8qYcveHnb-rrlok07qnCXjn8YSeCDDXlbhILSabgvNsPpbe76up8w63i2fWHvLKJzeGLKfyHg8ZomQ",
        and the armored data is "Tm90IHJlYWxseSBBdG9t" with MIME type
        application/atom+xml, then the Compact Serialization would be the string:
        "4k8ikoyC2Xh+8BiIeQ+ob7Hcd2J7/Vj3uM61dy9iRMI=.EvGSD2vi8qYcveHnb-rrlok07qn
        CXjn8YSeCDDXlbhILSabgvNsPpbe76up8w63i2fWHvLKJzeGLKfyHg8ZomQ.Tm90IHJlYWxse
        SBBdG9t.YXBwbGljYXRpb24vYXRvbSt4bWw=.YmFzZTY0dXJs.UlNBLVNIQTI1Ng"
        
</p>
<p>Any parameter MAY be omitted by leaving its slot empty, as indicated by two
        consecutive periods.  When the "encoding" parameter is omitted, a recipient MUST
        decode the envelope as if it had the value "base64url".  When the "alg" parameter
        is omitted, a recipient MUST interpret the message as if the "alg" parameter 
        had the value "RSA-SHA256".  The "data_type" parameter SHOULD NOT be omitted as it
        provides a defense against content type masquerading attacks.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4"></a><h3>3.4.&nbsp;
The Magic Envelope XML Serialization</h3>

<p>A Magic Envelope XML Document is defined in terms of the XML Information Set, 
        serialized as XML 1.0 [W3C.REC-xml-20040204] and identified with the 
        "application/magic-envelope+xml" media type. Magic Envelope XML Documents MUST be 
        well-formed XML. This specification does not define a DTD, and thus does not require validity 
        (in the sense used by XML).
</p>
<p>The following XML elements are in the namespace 'http://salmon-protocol.org/ns/magic-env',
        represented for brevity by the short prefix "me:" in the following definitions.
</p>
<p>When used as a standalone XML document, the root element MUST be me:env.  When incorporated
        as a subtree of another XML document, the root of the subtree MAY be an element specified
        elsewhere, with semantics documented by a specification relying on this one.
</p>
<p>The parameters are mapped to XML elements and attributes as follows.  Each parameter MUST appear
        exactly once per envelope.
</p>
<p></p>
<blockquote class="text"><dl>
<dt>The &lt;me:data&gt; element (REQUIRED):</dt>
<dd>Contains the "data" payload, an ASCII string, as 
            described in
            <a class='info' href='#params'>Section&nbsp;3.1<span> (</span><span class='info'>Magic Envelope Parameters</span><span>)</span></a>.  The element contains one REQUIRED attribute, "type",
            which contains the value of the "data_type" parameter.
        
</dd>
<dt>The &lt;me:encoding&gt; element (REQUIRED):</dt>
<dd>Contains the value of the "encoding" parameter.
</dd>
<dt>The &lt;me:alg&gt; element (REQUIRED):</dt>
<dd>Contains the value of the "alg" parameter.
</dd>
<dt>The &lt;me:sig&gt; element (REQUIRED):</dt>
<dd>Contains the value
          of the "sig" parameter, an ASCII string.  MAY be repeated multiple
          times to record multiple signatures over the same text.  MAY have a key_id
          attribute containing the "key_id" value for the signature.
</dd>
</dl></blockquote><p>
        Additional elements not defined by this specification MAY appear as children of any elements
        in this namespace. Processors MUST ignore
        elements they do not understand.
</p>
<p>Example:      
          </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;me:env xmlns:me='http://salmon-protocol.org/ns/magic-env'&gt;
  &lt;me:data type='application/atom+xml'&gt;
    PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPGVudHJ5IHhtbG5zPS
    dodHRwOi8vd3d3LnczLm9yZy8yMDA1L0F0b20nPgogIDxpZD50YWc6ZXhhbXBsZS5jb20s
    MjAwOTpjbXQtMC40NDc3NTcxODwvaWQ-ICAKICA8YXV0aG9yPjxuYW1lPnRlc3RAZXhhbX
    BsZS5jb208L25hbWUPHVyaT5hY2N0OmpwYW56ZXJAZ29vZ2xlLmNvbTwvdXJpPjwvYXV0a
    G9yPgogIDx0aHI6aW4tcmVwbHktdG8geG1sbnM6dGhyPSdodHRwOi8vcHVybC5vcmcvc3l
    uZGljYXRpb24vdGhyZWFkLzEuMCcKICAgICAgcmVmPSd0YWc6YmxvZ2dlci5jb20sMTk5O
    TpibG9nLTg5MzU5MTM3NDMxMzMxMjczNy5wb3N0LTM4NjE2NjMyNTg1Mzg4NTc5NTQnPnR
    hZzpibG9nZ2VyLmNvbSwxOTk5OmJsb2ctODkzNTkxMzc0MzEzMzEyNzM3LnBvc3QtMzg2M
    TY2MzI1ODUzODg1Nzk1NAogIDwvdGhyOmluLXJlcGx5LXRvPgogIDxjb250ZW50PlNhbG1
    vbiBzd2ltIHVwc3RyZWFtITwvY29udGVudD4KICA8dGl0bGUU2FsbW9uIHN3aW0gdXBzdH
    JlYW0hPC90aXRsZT4KICA8dXBkYXRlZD4yMDA5LTEyLTE4VDIwOjA0OjAzWjwvdXBkYXRl
    ZD4KPC9lbnRyeT4KICAgIA
  &lt;/me:data&gt;
  &lt;me:encoding&gt;base64url&lt;/me:encoding&gt;
  &lt;me:alg&gt;RSA-SHA256&lt;/me:alg&gt;
  &lt;me:sig key_id="4k8ikoyC2Xh+8BiIeQ+ob7Hcd2J7/Vj3uM61dy9iRMI="&gt;
    EvGSD2vi8qYcveHnb-rrlok07qnCXjn8YSeCDDXlbhILSabgvNsPpbe76up8w63i2f
    WHvLKJzeGLKfyHg8ZomQ
  &lt;/me:sig&gt;
&lt;/me:env&gt;
</pre></div><p>

        
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5"></a><h3>3.5.&nbsp;
The Magic Envelope JSON Serialization</h3>

<p>Magic Envelope JSON MUST be well formed JSON as defined in <a class='info' href='#RFC4627'>[RFC4627]<span> (</span><span class='info'>Crockford, D., &ldquo;The application/json Media Type for JavaScript Object Notation (JSON),&rdquo; July&nbsp;2006.</span><span>)</span></a>.  The parameters are serialized into
          a JSON object as a sequence of name/value pairs for the parameter names
          "data", "data_type", "encoding", and "alg".  These values are
          represented as JSON strings.
          The "sig" parameter is represented as a "sigs" name whose value is an
          array of objects; each object has a REQUIRED "value" with the
          signature string, and MAY have a "key_id" with the associated
          "key_id" parameter.
</p>
<p>Additional name/value pairs MAY appear within the JSON object and
         processors MUST ignore elements they
         do not understand.
</p>
<p>Example:      
          </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
{
  "data": "
    PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPGVudHJ5IHhtbG5zPS
    dodHRwOi8vd3d3LnczLm9yZy8yMDA1L0F0b20nPgogIDxpZD50YWc6ZXhhbXBsZS5jb20s
    MjAwOTpjbXQtMC40NDc3NTcxODwvaWQ-ICAKICA8YXV0aG9yPjxuYW1lPnRlc3RAZXhhbX
    BsZS5jb208L25hbWUPHVyaT5hY2N0OmpwYW56ZXJAZ29vZ2xlLmNvbTwvdXJpPjwvYXV0a
    G9yPgogIDx0aHI6aW4tcmVwbHktdG8geG1sbnM6dGhyPSdodHRwOi8vcHVybC5vcmcvc3l
    uZGljYXRpb24vdGhyZWFkLzEuMCcKICAgICAgcmVmPSd0YWc6YmxvZ2dlci5jb20sMTk5O
    TpibG9nLTg5MzU5MTM3NDMxMzMxMjczNy5wb3N0LTM4NjE2NjMyNTg1Mzg4NTc5NTQnPnR
    hZzpibG9nZ2VyLmNvbSwxOTk5OmJsb2ctODkzNTkxMzc0MzEzMzEyNzM3LnBvc3QtMzg2M
    TY2MzI1ODUzODg1Nzk1NAogIDwvdGhyOmluLXJlcGx5LXRvPgogIDxjb250ZW50PlNhbG1
    vbiBzd2ltIHVwc3RyZWFtITwvY29udGVudD4KICA8dGl0bGUU2FsbW9uIHN3aW0gdXBzdH
    JlYW0hPC90aXRsZT4KICA8dXBkYXRlZD4yMDA5LTEyLTE4VDIwOjA0OjAzWjwvdXBkYXRl
    ZD4KPC9lbnRyeT4KICAgIA",
  "data_type": "application/atom+xml",
  "encoding": "base64url",
  "alg": "RSA-SHA256",
  "sigs": [
    {
    "value": "EvGSD2vi8qYcveHnb-rrlok07qnCXjn8YSeCDDXlbhILSabgvNsPpbe76
    up8w63i2fWHvLKJzeGLKfyHg8ZomQ",
    "key_id": "4k8ikoyC2Xh+8BiIeQ+ob7Hcd2J7/Vj3uM61dy9iRMI="
    }
  ]
}
</pre></div><p>

        
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Standalone Magic Envelope Messages</h3>

<p>The application/magic-envelope+{xml,json} data structures MAY be used standalone, as a drop-in replacement
      for the data that is encoded in the data element.  This would be appropriate where the recipient understands 
      the Magic Envelope specification and can automatically decode the data to recover the original format.
      For example, instead of POSTing an application/atom+xml type entry to create a new blog post, a client
      could POST an application/magic-envelope+xml with data of type application/atom+xml.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Syndicating Magic Envelope Messages</h3>

<p>It may be useful to syndicate Atom entries which have been enveloped and signed.  This can be done in
        two ways:  By adding a me:provenance element to the existing Atom entry and essentially duplicating
        its content in a signed me:data element, or by completely replacing each signed Atom entry with the
        corresponding me:env element.
</p>
<p>Feed processors who understand Magic Signatures SHOULD treat me:env elements which verify correctly
        as if the underlying Atom entry had been sent.  The semantics of me:env elements whose signatures cannot
        be verified are undefined by this specification; processors MAY ignore them, produce an error, attach a
        warning, or perform other actions as required by their security model.  Specifications relying on this
        one SHOULD specify specific security models appropriate to their respective domains.
        
</p>
<a name="encoding"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Encoding of data and sig using base64url</h3>

<p>The data and sig fields of a Magic Envelope are encoded as armored ASCII strings using
      a procedure chosen to be robust in the face of various types of transports and storage systems.
      Specifically, the encoded form is safe to include directly as text in XML, a string in JSON, 
      a parameter in URLs, or as form data, without escaping.  This section defines the mapping between 
      arbitrary binary data (a stream of octets) and the armored form (an ASCII string). 
      The ASCII string is also chosen so as to be a valid and equivalent UTF-8 string.
</p>
<a name="encoding_details"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Encoding</h3>

<p>
          The basic procedure is to use the URL and Filename safe variant of the base64 encoding as described in
          <a class='info' href='#RFC4648'>RFC 4648<span> (</span><span class='info'>Josefsson, S., &ldquo;The Base16, Base32, and Base64 Data Encodings,&rdquo; October&nbsp;2006.</span><span>)</span></a> [RFC4648], section 5, hereafter known as
          "base64url" encoding.
          The result is a string that consists only of the ASCII alphanumeric characters along with
          '-' and '_', and possibly '='.  In regular expression form, this is
          "^[A-Za-z0-9\-_]*=?=?=?$".  This is the normalized
          form of the encoded data, and is the basis for the octet sequence that is used to generate the digital
          signature.  Implementations and transports MAY add arbitrary whitespace (ASCII values 0x09-0x0D and 0x20) 
          anywhere in this string after signing but before output so as to, e.g., comply with line length 
          restrictions in certain environments.
        
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Decoding</h3>

<p>
          The basic procedure is the reverse of encoding, with the additional step that whitespace from the
          input should be ignored.  This is necessary for robustness because some transports may insert
          whitespace, and is useful to allow for human readable formatting of documents in any case.
          </p>
<ol class="text">
<li>Normalize the string by removing all whitespace characters from input.
</li>
<li>Base64url decode the resulting string to produce the original binary data.
</li>
</ol><p>
        
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
The HMAC-SHA256 Private Key Signature Algorithm</h3>

<p>This section defines a basic HMAC based private key signature algorithm.
      HMAC key exchange and rotation is outside the scope of this specification, but
      may be defined in specifications relying on this one.
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Calculating the HMAC-SHA256 signature string</h3>

<p>First, create an HMAC-SHA256 signature using the algorithm described in 
        <a class='info' href='#RFC2104'>RFC 2104<span> (</span><span class='info'>Krawczyk, H., Bellare, M., and R. Canetti, &ldquo;HMAC: Keyed-Hashing for Message Authentication,&rdquo; February&nbsp;1997.</span><span>)</span></a> [RFC2104], using SHA-256 as the hash function H, base string
        described in <a class='info' href='#sbs'>Section&nbsp;3.2<span> (</span><span class='info'>The Signature Base String</span><span>)</span></a> as the input text, and the shared secret key K. 
        The resulting array of bytes
        is then base64url encoded to produce the "sig" parameter.
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
Signing and Verifying Messages with HMAC-SHA256</h3>

<p>Signing consists of calculating the "sig" parameter and serializing it along with the
        other parameters to create a Magic Envelope.  Verifying consists of re-calculating the
        expected "sig" parameter given the other parameters, and doing an exact string comparison
        of the "sig" parameters after normalization (whitespace removal).
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
The RSA-SHA256 Public Key Signature Algorithm</h3>

<p>This section defines the default public key signature algorithm for Magic Signatures.
      In addition to indicating the signing algorithm, use of RSA-SHA256 by default also implies
      use of the Magic Public Key Infrastructure <a class='info' href='#mpki'>Section&nbsp;8<span> (</span><span class='info'>Magic Public Key Infrastructure</span><span>)</span></a> to obtain public keys.
      Specifications relying on Magic Signatures MAY specify other mechanisms for key retrieval.
</p>
<a name="signing"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
Signing Messages with RSA-SHA256</h3>

<p>Signing a message consists of signing the contents of "data", 
      "data_type", "encoding", and "alg" using the chosen algorithm.  This section
      defines the "RSA-SHA256" algorithm, meaning the RSASSA-PKCS1-v1_5 signature algorithm from
      <a class='info' href='#RFC3447'>RFC 3447<span> (</span><span class='info'>Jonsson, J. and B. Kaliski, &ldquo;Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1,&rdquo; February&nbsp;2003.</span><span>)</span></a> [RFC3447] section 8.2, also known as PKCS#1, using SHA-256 as the hash
      function for EMSA-PKCS1-v1_5.
</p>
<p>Note: As best current crypto practices change, new algorithms
      will become available and both extensions and future revisions of
      this specification may include additional new public key algorithms (e.g.,
      RSASSA-PSS).  When both clients and servers have sufficiently
      widespread support for the latest algorithm, older algorithms
      (e.g., RSASSA-PKCS1-v1_5) will be deprecated and removed in subsequent
      revisions of this specification.
</p>
<p>The signature is computed as signature_octets = RSASSA-PKCS1-V1_5-SIGN (K, M), where K is the
        private signing key and M is the <a class='info' href='#sbs'>Signature Base String<span> (</span><span class='info'>The Signature Base String</span><span>)</span></a> defined
        above.  Thus M is produced by concatenating the
        following substrings together, separated by periods (ASCII 0x2E):
        </p>
<ol class="text">
<li>The armored string for "data" produced by <a class='info' href='#encoding_details'>Section&nbsp;5.1<span> (</span><span class='info'>Encoding</span><span>)</span></a>
</li>
<li>The Base64url encoding of the "data_type" parameter
</li>
<li>The Base64url encoding of the "encoding" parameter
</li>
<li>The Base64url encoding of the "alg" parameter
</li>
</ol><p>
        For example, if the
        armored data is "Tm90IHJlYWxseSBBdG9t" with MIME type
        application/atom+xml, then M would be the string:
        "Tm90IHJlYWxseSBBdG9t.YXBwbGljYXRpb24vYXRvbSt4bWw=.YmFzZTY0dXJs.UlNBLVNIQTI1Ng"
      
</p>
<p>For convenience we
        summarize the steps for the required EMSA-PKCS1-v1_5 with RSA-SHA256
        algorithm here.  In
        the following, '+' means string concatenation.
        </p>
<ol class="text">
<li>Let hash = the SHA256 hash digest of M
</li>
<li>Let prefix = the constant byte sequence
          
            [0x30, 0x31,
            0x30, 0xd, 0x6,
            0x9, 0x60, 0x86, 0x48, 0x1, 0x65, 0x3, 0x4, 0x2, 0x1, 0x5, 0x0, 0x4,
            0x20]
</li>
<li>Let k = the number of bytes in the public key modulus
</li>
<li>Let padding = '\xFF' repeated (k - length(prefix+hash) - 3)
            times
</li>
<li>Let emsa =  '\x00' + '\x01' + padding + '\x00' + prefix + hash
</li>
<li>RSA sign the emsa byte sequence
</li>
</ol><p>
    
</p>
<p>The signature is then encoded as in <a class='info' href='#encoding_details'>Section&nbsp;5.1<span> (</span><span class='info'>Encoding</span><span>)</span></a> and the resulting ASCII armored string
      stored as a "sig" signature.  The associated "key_id" is the key_id associated with that
      signing key and published per <a class='info' href='#mpki'>Section&nbsp;8<span> (</span><span class='info'>Magic Public Key Infrastructure</span><span>)</span></a>.  If the signer does not maintain
      individual key_ids, it SHOULD output the base64url
      encoded representation of the SHA-256 hash of public key's application/magic-key
      representation.
</p>
<a name="verifying"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2"></a><h3>7.2.&nbsp;
Verifying Messages with RSA-SHA256</h3>

<p>Verifying a message signature consists of verifying that "sig" is a valid signature for "data" using "alg".
      This specification defines only the "RSA-SHA256" verification algorithm, meaning the RSASSA-PKCS1-v1_5 
      verification algorithm from <a class='info' href='#RFC3447'>RFC 3447<span> (</span><span class='info'>Jonsson, J. and B. Kaliski, &ldquo;Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1,&rdquo; February&nbsp;2003.</span><span>)</span></a> [RFC3447] section 8.2.1.
</p>
<p>The verification is performed by executing RSASSA-PKCS1-V1_5-VERIFY
        ((n, e), M, S), where (n ,e)
        comprise the public key, M is the message string
        documented in <a class='info' href='#signing'>Section&nbsp;7.1<span> (</span><span class='info'>Signing Messages with RSA-SHA256</span><span>)</span></a>,
        and S is the decoded value of a selected "sig".  (Note that this
        algorithm creates the emsa byte sequence as in <a class='info' href='#signing'>Section&nbsp;7.1<span> (</span><span class='info'>Signing Messages with RSA-SHA256</span><span>)</span></a>
        and then performs RSA verification using (n, e), emsa, and S.)
</p>
<p>The scope of the verification covers only the contents of the Magic Envelope itself.  In some
      cases, the information from the decoded "data" value
      must be checked against or override the enclosing data.  The mechanisms for this are
      specific to the kinds of data, but in general a secure if lossy mechanism
      is to throw away the unverified information and replace it with the output of the decoded 
      "data".
      The correct mechanism depends on the
      security model required by the processor
      and is outside the scope of this specification.
</p>
<p>It is RECOMMENDED that signed content contain expiration
      information after which the signed data SHOULD NOT be verified or
      used without additional confirmation.  Such confirmation is
      outside the scope of this specification.  However, when this is
      done and signing keys also expire on a predictable time in the
      future, signers SHOULD ensure that the content expiration is not
      after the known key expiration time.  That is, the signed content
      should expire no later than the expiration date of the key used to
      sign it.
</p>
<p>Note that emergency key revocation is outside the
      scope of this specification.  However, implementations SHOULD
      honor HTTP cache control directives when retrieving key material
      and SHOULD NOT use keys for verification without revalidating the
      content as directed by the origin server.  This allows origin servers
      to trade off performance for smaller periods of vulnerability.
</p>
<p>Unless specified otherwise, the public key (n, e) is obtained using the 
      simple public key infrastructure described by 
      <a class='info' href='#mpki'>Section&nbsp;8<span> (</span><span class='info'>Magic Public Key Infrastructure</span><span>)</span></a>.  Note that several candidate signing keys may be
      retrieved, and in the worst case verifiers MUST try each one with equal key_id 
      until at least one successfully verifies the signature.  Two key IDs are equal
      if their individual octets are equal and they are of equal length.  A signature
      with an empty (missing) key_id, which may have been signed by any key, MUST
      be verified against all available keys.
</p>
<a name="mpki"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Magic Public Key Infrastructure</h3>

<p>This section defines a public key infrastructure based on URIs.  It uses LRDD discovery
      plus direct retrieval via secure URLs. 
      Specifically, given a signer URI such as "acct:bob@example.com" or "http://example.com/bob",
      the corresponding 
      public key(s) for that identifier can be found discovery as defined below.  The result
      is a set of RSA public keys in a simple string format.
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.1"></a><h3>8.1.&nbsp;
The application/magic-key MIME type</h3>

<p>The application/magic-key format is a very minimal format for representing public key data.
        It consists of a string of ASCII text, separated into 3 components, with components separated 
        by a "." (0x2E) character.  The first component is the key type; this specification only defines
        the "RSA" key type for future upgradeability.  Thus a magic key consists of the string 
        "RSA.modulus(n).exponent(e)"; for example:
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
RSA.mVgY8RN6URBTstndvmUUPb4UZTdwvwmddSKE5z_jvKUEK6yk1u3rrC9yN8k6FilGj9K0eeUPe2hf4Pj-5CmHww.AQAB
</pre></div><p>
        
        The pair (n, e) is used as input to RSASSA-PKCS1-V1_5-VERIFY.
</p>
<p>Each of the components is first represented as an integer in network byte order (big endian),
        with no leading zero bytes, and
        encoded via the "base64url" mechanism described in <a class='info' href='#params'>Section&nbsp;3.1<span> (</span><span class='info'>Magic Envelope Parameters</span><span>)</span></a>.
        
</p>
<p>This specification defines only a public key format, and anticipates that keypairs may be stored
        securely in other formats (e.g., DER encoded X.509 certificates) and that the application/magic-key
        data will be generated via tools.
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.2"></a><h3>8.2.&nbsp;
Discovery</h3>

<p>This section defines how to map from a signer URI identifier to a set of public signing keys 
        for that identifier.  The exact mechanism for a verifier to determine the
        signer URI is outside the scope of this specification, and MUST be specified by the
        particular protocol or application of Magic Signatures.  The URI identifier MUST appear
        within, or be derived from, information within the "data" parameter and therefore be covered
        by the signature.
</p>
<p>Many existing formats contain authorship, sender, or issuer
        fields and these SHOULD be used or extended where possible.  Protocols which rely 
        on Magic Signatures for digital
        signatures MUST specify a format-dependent model for determining
        potential signer URIs given the signed data.
        This section describes the subsequent discovery step:
        How to take a general URI and securely map it to a set of public signing keys
        with optional key ids.
</p>
<p>The end result of discovery will be a collection of magic keys.  Each magic key 
        has a "data" parameter, a string in application/magic-key format; and an optional
        "key_id" parameter, a string as defined below.  If the key_id is omitted from
        a key, it defaults to the Base64url encoding of the SHA-256 hash of the "value"
        parameter.  That is, when doing discovery, processors MUST assume that an omitted key_id is
        equivalent to specifying key_id = Base64url(SHA-256(value)).  A signer MAY then use
        this value as a key_id on a signature in order to signal use of that key.
</p>
<p>There are two standard serializations
        of this collection, one for JSON and one for XML.  Both are intended to be embeddable
        within general discovery metadata.
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.2.1"></a><h3>8.2.1.&nbsp;
The JSON Serialization of Magic Keys</h3>

<p>The keys are stored within an array named "magic_keys".  The array's values are
          objects, each of which MUST have a string "value" element containing the application/magic-key
          string, and which MAY have a string "key_id" element containing the id of that key.
</p>
<p>Example:
          </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
{
  "magic_keys": [
    {"value": "RSA.mVgY8RN6URBTstndvmUUPb4UZTdwvwmddSKE5z_jvKUEK6yk1u3rrC9yN8k6FilGj9K0eeUPe2hf4Pj-5CmHww.AQAB",
     "key_id": "1"},
    {"value": "RSA.wvwmdK0eeUPe2hURBTstndvmUUPb4UZTd6wvwmddSrrC89yN8k6FilGwvwmddSKE5z_jvKUEKj9f4Pj-5CmHww.AQAB",
     "key_id": "2"}
  ]
}
</pre></div><p>

          
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.2.2"></a><h3>8.2.2.&nbsp;
The XRD XML Serialialization of Magic Keys</h3>

<p>The keys are stored as XRD Property elements within the XRD document.  The type of
          the Property element is "http://salmon-protocol.org/ns/magic-key" and this is also
          the XML namespace of dependent elements and attributes.
          Each one has an optional mk:key_id
          attribute containing the key's id; the body of the Property element contains the
          application/magic-key string data.
</p>
<p>Example:
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
&lt;Property xmlns:mk="http://salmon-protocol.org/ns/magic-key"
          type="http://salmon-protocol.org/ns/magic-key"
          mk:key_id="1"&gt;
  RSA.mVgY8RN6URBTstndvmUUPb4UZTdwvwmddSKE5z_jvKUEK6yk1u3rrC9yN8k6FilGj9K0eeUPe2hf4Pj-5CmHww.AQAB
&lt;/Property&gt;
&lt;Property xmlns:mk="http://salmon-protocol.org/ns/magic-key"
          type="http://salmon-protocol.org/ns/magic-key"
          mk:key_id="2"&gt;
  RSA.wvwmdK0eeUPe2hURBTstndvmUUPb4UZTd6wvwmddSrrC89yN8k6FilGwvwmddSKE5z_jvKUEKj9f4Pj-5CmHww.AQAB
&lt;/Property&gt;
</pre></div><p>
          
          
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.2.3"></a><h3>8.2.3.&nbsp;
Discovery Flow</h3>

<p>Given a URI U, first perform discovery on U per 
          <a class='info' href='#LRDD'>Webfinger/LRDD<span> (</span><span class='info'>Eran, E., &ldquo;LRDD: Link-based Resource Descriptor Discovery,&rdquo; .</span><span>)</span></a> [LRDD] and interpret the result per the XRD
          XML Serialization.  If this step produces a set of keys, stop.  Otherwise,
          if U is an https URL, directly retrieve the resource U via SSL, performing necessary
          certificate checks, and see if the resulting data is of type 
          application/metadata+json.  If so, look for the "magic_public_keys" array as per
          the JSON Serialization.  If both of these steps fail to produce a set of keys, stop.
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.2.4"></a><h3>8.2.4.&nbsp;
Key Selection</h3>

<p>Once a set of possible key candidates have been determined, via discovery or alternatively
          via an extension mechanism outside the scope of this specification, a verifier must
          then determine whether a given signature is valid.  This section details how to do so
          in an interoperable way.
</p>
<p>Among the available keys, select the key for verification by matching the key_id
          against the key_id specified in the signature.  In this context an empty string key_id
          matches everything.  This produces a smaller set of possible keys to use for verification.
          Verification succeeds if any one of these keys successfully verifies the signature.
</p>
<p>Note that in the case of multiple signatures, it is possible for one signature to be
          verified but for others to fail.  Specifications relying on Magic Signatures MUST specify
          the semantics in these cases.
</p>
<a name="Acknowledgements"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Acknowledgements</h3>

<p>This document is the outcome of meetings and feedback from a large number of people.
      In particular, feedback from the Federated Social Web, Webfinger, OAuth, Activity Streams,
      and Salmon Protocol 
      communities has been invaluable.  Some of the people who contributed
      to this effort are:
</p>
<p>
      Bob Aman,
      Darren Bounds,
      Charlie Cauthen,
      DeWitt Clinton,
      George Fletcher,
      Hunter Freyer,
      Eran Hammer-Lahav,
      Timothy Jordan,
      Mike Macgirvin,
      James Manger,
      Sean McCullough,
      Breno de Medeiros,
      Chris Messina,
      Will Norris,
      Ade Oshineye,
      NeilFred Piccolo,
      Evan Prodromou,
      Arne Roomann-Kurrik,
      Brett Slatkin,
      Joseph Smarr,
      James Snell,
      Brian Stoler,
      James Walker,
      Stephen Paul Weber,
      Bob Wyman.
      
</p>
<p>The authors apologize for any omissions from this list, which are certainly unintentional.
</p>
<a name="IANA"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
IANA Considerations</h3>

<p>This specification introduces three new media types.
</p>
<p>The MIME media type for the XML serialization of a Magic Envelope is application/magic-env+xml.
</p>
<p>Type name: application
</p>
<p>Subtype name: magic-env+xml
</p>
<p>Required parameters: n/a
</p>
<p>Optional parameters: n/a
</p>
<p>The MIME media type for the unique JSON serialization of a Magic Envelope is application/magic-env+json, though
         application/json is also appropriate.
</p>
<p>Type name: application
</p>
<p>Subtype name: magic-env+json
</p>
<p>Required parameters: n/a
</p>
<p>Optional parameters: n/a
</p>
<p>The MIME media type for key(pairs) is application/magic-key.
</p>
<p>Type name: application
</p>
<p>Subtype name: magic-key
</p>
<p>Required parameters: n/a
</p>
<p>Optional parameters: n/a
</p>
<a name="Security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
Security Considerations</h3>

<p>Specific security considerations are embedded in the relevant functional sections above.
      In general, with reference to
      <a class='info' href='#RFC3552'>[RFC3552]<span> (</span><span class='info'>Rescorla, E. and B. Korver, &ldquo;Guidelines for Writing RFC Text on Security Considerations,&rdquo; July&nbsp;2003.</span><span>)</span></a>, Magic Signatures is a message oriented security protocol
      that provides object level data integrity and data origin (sender) authentication.
      It leaves other security considerations, and specific
      threat models, to relying specifications.  In particular, note that:
      </p>
<ol class="text">
<li>Core Magic Signatures
        addresses neither confidentiality nor replay attacks.  Relying specifications SHOULD address
        these issues as appropriate, e.g., by ensuring that messages are idempotent.
</li>
<li>Magic Signatures defines only a basic set of key validity checks.  A key which passes these
        checks may still be invalid for other reasons (e.g., if it has been revoked by some
        mechanism outside the scope of this specification).  Specifications relying on Magic Signatures
        SHOULD specify additional validity checks as appropriate.
</li>
<li>Magic Signatures relies on the existence of a reliable domain name service and TLS
        for bootstrapping domain-level discovery information, and is dependent on the proper
        end-to-end implementation of TLS, including operational security of web servers, avoiding
        non-TLS redirects, honoring certificate revocation lists, and maintaining an appropriate set 
        of trusted root CAs.  Leveraging DNSSEC, when available, to reduce the CA attack
        surface is RECOMMENDED.
</li>
<li>Magic Signatures leaves other security issues
        for relying specifications.
</li>
</ol><p>
      
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>12.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="LRDD">[LRDD]</a></td>
<td class="author-text">Eran, E., &ldquo;<a href="http://tools.ietf.org/html/draft-hammer-discovery-04">LRDD: Link-based Resource Descriptor Discovery</a>.&rdquo;</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2045">[RFC2045]</a></td>
<td class="author-text"><a href="mailto:ned@innosoft.com">Freed, N.</a> and <a href="mailto:nsb@nsb.fv.com">N. Borenstein</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2045">Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</a>,&rdquo; RFC&nbsp;2045, November&nbsp;1996 (<a href="http://www.rfc-editor.org/rfc/rfc2045.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2104">[RFC2104]</a></td>
<td class="author-text"><a href="mailto:hugo@watson.ibm.com">Krawczyk, H.</a>, <a href="mailto:mihir@cs.ucsd.edu">Bellare, M.</a>, and <a href="mailto:canetti@watson.ibm.com">R. Canetti</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2104">HMAC: Keyed-Hashing for Message Authentication</a>,&rdquo; RFC&nbsp;2104, February&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2104.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3447">[RFC3447]</a></td>
<td class="author-text">Jonsson, J. and B. Kaliski, &ldquo;<a href="http://tools.ietf.org/html/rfc3447">Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1</a>,&rdquo; RFC&nbsp;3447, February&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3447.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3552">[RFC3552]</a></td>
<td class="author-text">Rescorla, E. and B. Korver, &ldquo;<a href="http://tools.ietf.org/html/rfc3552">Guidelines for Writing RFC Text on Security Considerations</a>,&rdquo; BCP&nbsp;72, RFC&nbsp;3552, July&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3552.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4287">[RFC4287]</a></td>
<td class="author-text"><a href="mailto:mnot@pobox.com">Nottingham, M., Ed.</a> and <a href="mailto:rfsayre@boswijck.com">R. Sayre, Ed.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc4287">The Atom Syndication Format</a>,&rdquo; RFC&nbsp;4287, December&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4287.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc4287.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc4287.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4627">[RFC4627]</a></td>
<td class="author-text">Crockford, D., &ldquo;<a href="http://tools.ietf.org/html/rfc4627">The application/json Media Type for JavaScript Object Notation (JSON)</a>,&rdquo; RFC&nbsp;4627, July&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4627.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4648">[RFC4648]</a></td>
<td class="author-text">Josefsson, S., &ldquo;<a href="http://tools.ietf.org/html/rfc4648">The Base16, Base32, and Base64 Data Encodings</a>,&rdquo; RFC&nbsp;4648, October&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4648.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="XMLDSIG">[XMLDSIG]</a></td>
<td class="author-text">&ldquo;<a href="http://www.w3.org/TR/xmldsig-core">XML Signature Syntax and Processing (Second Edition)</a>.&rdquo;</td></tr>
<tr><td class="author-text" valign="top"><a name="XRD">[XRD]</a></td>
<td class="author-text">Eran, EHL. and WN. Will, &ldquo;<a href="http://tools.oasis-open.org/version-control/browse/wsvn/xri/xrd/1.0/drafts/wd13/xrd-1.0-wd13.html">Extensible Resource Descriptor (XRD) Version 1.0, Working Draft 13</a>.&rdquo;</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>12.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.narten-iana-considerations-rfc2434bis">[I-D.narten-iana-considerations-rfc2434bis]</a></td>
<td class="author-text">Narten, T. and H. Alvestrand, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-narten-iana-considerations-rfc2434bis-09.txt">Guidelines for Writing an IANA Considerations Section in RFCs</a>,&rdquo; draft-narten-iana-considerations-rfc2434bis-09 (work in progress), March&nbsp;2008 (<a href="http://www.ietf.org/internet-drafts/draft-narten-iana-considerations-rfc2434bis-09.txt">TXT</a>).</td></tr>
</table>

<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
Specification Feedback</h3>

<p>The primary driver of this specification is the Salmon protocol.
      Feedback on this specification is thus welcomed via the salmon-discuss mailing
      list, salmon-protocol@googlegroups.com.  For more information, see 
      <a href='http://groups.google.com/group/salmon-protocol'>the Salmon discussion
      group</a>.  Bugs and errata may also be reported via
      <a href='http://code.google.com/p/salmon-protocol/issues/list'>the Salmon bug tracker</a>.
</p>
<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">John Panzer (editor)</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Google Inc.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">1600 Ampitheatre Parkway</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Mountain View, CA  </td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text"></td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:jpanzer@google.com">jpanzer@google.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Ben Laurie</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Google Inc.</td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Dirk Balfanz</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Google Inc.</td></tr>
</table>
</body></html>
